
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>LEUVENFLYERS – Campaign XX2602 (Map)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no"/>
  <meta name="theme-color" content="#2563eb">

  <!-- Performance hints -->
  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://a.basemaps.cartocdn.com">
  <link rel="dns-prefetch" href="https://b.basemaps.cartocdn.com">
  <link rel="dns-prefetch" href="https://c.basemaps.cartocdn.com">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- PWA -->
  <link rel="manifest" href="https://raw.githubusercontent.com/leuvenfd/coinfun/refs/heads/main/and.json">
  <link rel="apple-touch-icon" href="https://www.iconpacks.net/icons/2/free-location-map-icon-2956-thumb.png">
  <link rel="apple-touch-startup-image" href="https://www.iconpacks.net/icons/2/free-location-map-icon-2956-thumb.png">

  <!-- Fonts and styles -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Material+Icons+Outlined&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>

  <style>
  :root {
    --brand: #1877F2;
    --accent-soft: #E7F3FF;
    --success: #31A24C;
    --success-soft: rgba(49, 162, 76, 0.10);
    --warning: #F5C33B;
    --warning-soft: rgba(245, 195, 59, 0.16);
    --danger: #E41E3F;

    --ink-900: #1C1E21;
    --ink-800: #4B4F56;
    --ink-700: #606770;
    --ink-600: #8A8D91;
    --ink-500: #BEC3C9;
    --ink-400: #CCD0D5;
    --ink-300: #E4E6EB;
    --ink-200: #F0F2F5;
    --ink-100: #F5F6F7;

    --surface: #ffffff;

    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.08);

    --focus-ring: 0 0 0 3px rgba(24, 119, 242, 0.25);
    --footer-h: 40px;
    --chip-h: 56px;
    --header-row-gap: 6px;
    --chip-radius: 12px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body {
    width: 100%; height: 100%; overflow: hidden;
    font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    font-size: 12px; line-height: 1.4;
    background: var(--ink-200); color: var(--ink-900);
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
  }
  body { display: flex; flex-direction: column; }
  a { color: var(--brand); text-decoration: none; }
  a:hover { text-decoration: underline; }

  @media (prefers-reduced-motion: reduce) {
    * { animation: none !important; transition: none !important; }
  }
  .reduced-motion * { animation: none !important; transition: none !important; }

  /* Top Bar */
  .topbar {
    background: var(--surface);
    border-bottom: 1px solid var(--ink-300);
    color: var(--ink-900); z-index: 600;
    box-shadow: var(--shadow-sm);
    position: fixed; top: 0; left: 0; right: 0; display: flex; flex-direction: column;
    padding: 8px 10px; gap: var(--header-row-gap);
  }
  .brand-title { color: var(--brand); font-weight: 700; letter-spacing: .2px; }
  .campaign-badge { background: var(--accent-soft); color: var(--brand); font-weight: 600; border-radius: 8px; padding: 2px 6px; }
  button.icon-btn {
    background: var(--ink-200); border: 1px solid var(--ink-300);
    color: var(--ink-800); border-radius: 10px; width: 36px; height: 36px;
    position: relative; cursor: pointer;
  }
  button.icon-btn:hover { background: var(--ink-300); }

  .notif-badge {
    position: absolute; top: -2px; right: -2px;
    min-width: 18px; height: 18px; border-radius: 999px;
    color: #fff; background-color: var(--danger);
    font-size: 10px; font-weight: 700; line-height: 18px; text-align: center;
    padding: 0 5px; box-shadow: 0 0 0 2px var(--surface);
  }

  /* Panels */
  .notifications, .chat-panel {
    background: var(--surface); border: 1px solid var(--ink-300);
    border-radius: 12px; box-shadow: var(--shadow-md);
    position: fixed; top: calc(var(--topbar-total-height) + 6px); right: 10px;
    display: none; flex-direction: column; overflow: hidden; z-index: 650;
  }
  .notifications.visible, .chat-panel.visible { display: flex; }
  .notifications .notif-list, .chat-panel .chat-list {
    content-visibility: auto;
    contain-intrinsic-size: 240px 320px;
  }

  /* Notifications */
  .notifications { width: 320px; }
  .notif-header { color: var(--ink-900); font-weight: 600; font-size: 13px; padding: 12px 16px 8px; }
  .notif-item { padding: 12px 16px; display: flex; gap: 10px; font-size: 11px; border-top: 1px solid var(--ink-300); cursor: pointer; align-items: center; background: transparent; }
  .notif-item:first-child { border-top: none; }
  .notif-item:hover { background: var(--ink-100); }
  .notif-icon {
    width: 26px; height: 26px; border-radius: 8px;
    background: var(--accent-soft); color: var(--brand);
    font-size: 16px; display: flex; align-items: center; justify-content: center;
  }
  .notif-msg, .notif-empty { color: var(--ink-800); }
  .notif-footer { color: var(--ink-700); padding: 6px 12px 8px; font-size: 10px; text-align: right; border-top: 1px solid var(--ink-300); }
  .notifications.scroll-after-4 .notif-list { max-height: 240px; overflow-y: auto; }
  .notif-empty { padding: 18px 14px; font-size: 11px; }
  .notif-item[data-zone]::after{content:"View";font-size:9px;font-weight:600;color:var(--brand);align-self:center;margin-left:6px;opacity:.55;}
  .notif-item[data-zone]:hover::after{opacity:1;}

  /* Chat UI */
  .chat-panel { width: 360px; max-width: 92vw; height: 60vh; max-height: 70vh; min-height: 360px; }
  .chat-header { padding: 12px 16px; border-bottom: 1px solid var(--ink-300); flex-shrink: 0; }
  .chat-title { font-size: 14px; font-weight: 600; color: var(--ink-900); }
  .chat-actions { display: flex; gap: 6px; align-items: center; }
  .chat-mark-btn{appearance:none;border:1px solid var(--ink-300);background:var(--surface);color:var(--ink-700);font-size:10px;font-weight:700;padding:4px 8px;border-radius:10px;cursor:pointer;}
  .chat-mark-btn:hover{background:var(--ink-200);}
  .chat-list { flex-grow: 1; overflow-y: auto; padding: 12px; background: var(--surface); }
  .chat-row{display:flex;gap:8px;align-items:flex-end;}
  .chat-row + .chat-row { margin-top: 10px; }
  .chat-row.mine{justify-content:flex-end;}
  .chat-msg {
    border: 1px solid var(--ink-300); color: var(--ink-900);
    border-radius: 10px;
    padding: 8px 12px;
    background: var(--ink-100);
    max-width: 80%;
    box-shadow: var(--shadow-sm);
  }
  .chat-row.mine .chat-msg { background: var(--brand); color: #fff; border-color: transparent; }
  .chat-row .avatar {
    width: 26px; height: 26px; border-radius: 8px;
    background: var(--ink-300); color: var(--ink-800);
    flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: 600;
  }
  .chat-msg .chat-text{font-size:12px;white-space:pre-wrap;word-break:break-word;line-height:1.45;}
  .chat-msg .chat-meta{margin-top:4px;font-size:9px;color:var(--ink-500);display:flex;gap:6px;align-items:center;}

  .chat-input-row { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-top: 1px solid var(--ink-300); background: var(--surface); flex-shrink: 0; }
  .chat-input {
    flex-grow: 1; background: var(--ink-100);
    border: 1px solid var(--ink-300);
    border-radius: 10px;
    color: var(--ink-900);
    padding: 8px 12px; font-size: 12px;
    resize: none; line-height: 1.4;
  }
  .chat-input:focus { border-color: var(--brand); box-shadow: var(--focus-ring); background: #fff; outline: none; }
  .send-btn {
    background: var(--brand); color: #fff; box-shadow: none;
    border-radius: 10px; width: 36px; height: 32px; flex-shrink: 0; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }
  .send-btn:hover { filter: brightness(1.06); }
  .send-btn:focus-visible { outline: none; box-shadow: var(--focus-ring); }

  /* Map */
  #map { background: var(--ink-100); position: absolute; top: calc(var(--topbar-total-height)); left: 0; right: 0; bottom: var(--footer-h); }
  .leaflet-tile-pane { filter: none !important; }
  .leaflet-control-zoom a { background: var(--surface) !important; color: var(--ink-900) !important; border: 1px solid var(--ink-300); border-radius: 8px; }

  /* Leaflet popup */
  .leaflet-popup-content-wrapper { background: var(--surface); color: var(--ink-900); border: 1px solid var(--ink-300); border-radius: 12px; box-shadow: var(--shadow-md); }
  .leaflet-popup-tip { background: var(--surface); box-shadow: none; border: 1px solid var(--ink-300); }
  .leaflet-popup-close-button { color: var(--ink-600) !important; }
  .leaflet-popup-close-button:hover { color: var(--ink-900) !important; background: var(--ink-200) !important; border-radius: 6px; }

  /* Zone Labels */
  .leaflet-div-icon.zone-label-wrapper{background:transparent !important;border:none !important;}
  .zone-label {
    background: var(--surface);
    border: 1px solid var(--ink-300);
    color: var(--ink-900);
    border-radius: 12px;
    font-weight: 700;
    font-size: 11px;
    padding: 2px 8px;
    display: inline-flex; align-items: center; justify-content: center; gap: 8px;
    box-shadow: var(--shadow-sm);
  }
  .zone-label .zone-num { font-weight: 800; }

  /* Flyers badge with mail icon (separate from zone number; non-green to avoid confusion) */
  .zone-label .flyers-badge {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 2px 6px; border-radius: 999px;
    background: #ffffff; color: var(--brand); border: 1px solid var(--ink-300);
    font-size: 10px; font-weight: 700;
    box-shadow: 0 1px 2px rgba(0,0,0,0.08);
  }
  .zone-label .flyers-badge .material-icons-outlined {
    font-size: 12px; line-height: 1; color: var(--brand);
  }

  .zone-label.tiny { background: var(--brand); color: #fff; border-color: transparent; padding: 2px 6px; font-size: 9px; font-weight: 600; box-shadow: none; }
  .zone-label.status-booked { background: var(--warning); color: var(--ink-900); border-color: transparent; }
  .zone-label.status-completed { background: var(--success); color: #fff !important; border-color: transparent; }

  /* Footer & Proof Strip */
  .footer {
    background: var(--surface); border-top: 1px solid var(--ink-300); color: var(--ink-800);
    position: fixed; bottom: 0; left: 0; right: 0; height: var(--footer-h);
    z-index: 550; display: flex; align-items: center; justify-content: space-between; padding: 0 12px; font-size: 11px;
  }
  .proof-strip {
    border: 1px solid var(--ink-300); box-shadow: var(--shadow-md); border-radius: 12px;
    position: fixed; left: 10px; right: 10px; bottom: calc(var(--footer-h) + 8px);
    height: 56px; align-items: center; gap: 6px; z-index: 570; display: none; background: var(--surface);
  }
  .proof-strip.visible { display: flex; }
  .proof-strip-inner { display: flex; align-items: center; gap: 8px; overflow-x: auto; flex: 1; scrollbar-width: none; -webkit-overflow-scrolling: touch; padding: 6px; }
  .proof-strip-inner::-webkit-scrollbar{ display: none; }
  .proof-item {
    position: relative; flex: 0 0 auto; width: 44px; height: 44px; border-radius: 10px; overflow: hidden; cursor: pointer;
    box-shadow: var(--shadow-sm); transition: transform .08s ease, box-shadow .08s ease, border-color .08s ease; border: 1px solid var(--ink-300); background: #fff;
  }
  .proof-item:hover { transform: translateY(-1px); box-shadow: 0 3px 8px -6px rgba(0,0,0,.1); border-color: var(--ink-400); }
  .proof-item.selected{ outline: 2px solid var(--brand); outline-offset: 2px; }
  .proof-thumb{ width: 100%; height: 100%; object-fit: cover; display: block; }
  .proof-badge{ display: none !important; }
  .ps-btn { background: var(--ink-100); border: 1px solid var(--ink-300); color: var(--ink-800); border-radius: 10px; height: 32px; width: 32px; display: grid; place-items: center; }
  .ps-btn .material-icons-outlined{ font-size: 18px; }

  /* Loading Overlay */
  #loadingOverlay { position: fixed; inset: 0; display: grid; place-items: center; gap: 8px; background: var(--surface); color: var(--ink-900); z-index: 800; }
  #loadingOverlay.fade-out{ opacity: 0; pointer-events: none; transition: opacity .18s ease; }
  .loader { width: 26px; height: 26px; border-radius: 50%; border: 4px solid var(--ink-300); border-top-color: var(--brand); animation: spin 0.7s linear infinite; }
  @keyframes spin{ to{ transform: rotate(360deg); } }
  .mini-hint{ margin-top: 8px; font-size: 11px; opacity: .85; line-height: 1.4; text-align: center; }

  /* Proof camera marker */
  .proof-icon {
    width: 26px; height: 26px;
    display: grid; place-items: center;
    background: #ffffff;
    border: 1px solid var(--ink-300);
    border-radius: 50%;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  }
  .proof-icon .material-icons-outlined {
    font-size: 16px; color: #1976d2; line-height: 1;
  }

  /* Simple, better looking stats chips */
  .metrics-scroll {
    display: flex; align-items: center; gap: 10px; overflow-x: auto;
    padding: 6px 4px 8px; background: var(--surface);
    border-top: 1px solid var(--ink-300);
    scrollbar-width: none; -webkit-overflow-scrolling: touch;
  }
  .metrics-scroll::-webkit-scrollbar{ display: none; }

  .metric-chip {
    flex: 0 0 auto;
    display: grid;
    grid-template-columns: 28px auto;
    align-items: center;
    gap: 8px;
    min-width: 160px;
    height: var(--chip-h);
    padding: 8px 12px;
    border: 1px solid var(--ink-300);
    border-radius: var(--chip-radius);
    background: var(--surface);
    box-shadow: var(--shadow-sm);
  }
  .metric-chip .material-icons-outlined { font-size: 18px; color: var(--ink-700); }
  .metric-chip .stack {
    display: flex; flex-direction: column; gap: 2px;
  }
  .metric-chip .label {
    font-size: 10px; color: var(--ink-700); font-weight: 600; letter-spacing: .2px;
  }
  .metric-chip .value {
    font-weight: 800; font-size: 14px; color: var(--ink-900);
  }

  /* Variants (subtle, simple) */
  .metric-chip.success { border-color: #bfe8cc; background: #f2fbf5; }
  .metric-chip.success .material-icons-outlined { color: #2e7d32; }
  .metric-chip.warning { border-color: #f5e2ad; background: #fff9e8; }
  .metric-chip.warning .material-icons-outlined { color: #b38700; }
  .metric-chip.danger { border-color: #f3b6bf; background: #fff5f7; }
  .metric-chip.danger .material-icons-outlined { color: #b3261e; }
  .metric-chip.info { border-color: #c6defb; background: #f5faff; }
  .metric-chip.info .material-icons-outlined { color: #1877F2; }

  @media (max-width:420px){
    .brand-title{font-size:12px;}
    .campaign-badge{display:none;}
    .metric-chip{min-width: 136px; height: 52px; padding: 6px 10px;}
    .metric-chip .value{font-size:13px;}
  }
  </style>
</head>
<body>
  <div id="loadingOverlay" aria-live="polite">
    <div class="loader" aria-hidden="true"></div>
    <div><strong>Please wait</strong>, full data & map are loading...</div>
    <div class="mini-hint">
      Once loaded we will automatically zoom into the most recently <strong>completed zone</strong>.<br/>
      You can still pan / pinch after that.
    </div>
  </div>

  <header class="topbar" id="topbar">
    <div class="topbar-row primary-row" style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;width:100%;">
      <div class="brand-block" style="display:flex;align-items:center;gap:8px;min-width:0;flex:1;">
        <span class="material-icons-outlined brand-icon" style="font-size:18px;flex-shrink:0;">map</span>
        <div style="display:flex;flex-direction:column;gap:2px;min-width:0;">
          <span class="brand-title">LEUVENFLYERS</span>
          <span class="campaign-badge">Campaign XX2602</span>
        </div>
      </div>
      <div class="right-controls" style="display:flex;align-items:center;gap:6px;flex:0 0 auto;">
        <button id="recentBtn" class="icon-btn" title="Zoom to most recent completed zone" aria-label="Zoom to most recent completed zone">
          <span class="material-icons-outlined">my_location</span>
        </button>
        <button id="chatBtn" class="icon-btn" aria-label="Chat" title="Chat">
          <span class="material-icons-outlined">chat</span>
          <span id="chatBadge" class="notif-badge chat-badge"></span>
        </button>
        <button id="notifBtn" class="icon-btn" aria-label="Notifications">
          <span class="material-icons-outlined">notifications</span>
          <span id="notifBadge" class="notif-badge"></span>
        </button>
      </div>
    </div>

    <!-- Simple, better-looking stats boxes -->
    <div class="metrics-scroll" id="metricsScroll" aria-label="Campaign metrics">
      <div class="metric-chip info" title="Total Flyers">
        <span class="material-icons-outlined">inventory_2</span>
        <div class="stack">
          <span class="label">Total Flyers</span>
          <span class="value" id="flyersTotal">0</span>
        </div>
      </div>
	  
	   <div id="qrCounter" class="metric-chip info" style="cursor:pointer;" title="QR Scan Count">
        <span class="material-icons-outlined">qr_code_scanner</span>
        <div class="stack">
          <span class="label">QR Scans</span>
          <span class="value" id="qrScanCount">0</span>
        </div>
      </div>

      <div class="metric-chip success" title="Completed / Verified Flyers">
        <span class="material-icons-outlined">task_alt</span>
        <div class="stack">
          <span class="label">Completed Flyers</span>
          <span class="value" id="flyersDistributed">0</span>
        </div>
      </div>


      <div class="metric-chip warning" title="Flyers Required (Booked)">
        <span class="material-icons-outlined">group</span>
        <div class="stack">
          <span class="label">Required Flyers</span>
          <span class="value" id="flyersRequired">0</span>
        </div>
      </div>

     

      <!-- Live count: title then number only -->
      <div class="metric-chip info" title="Live count">
        <span class="material-icons-outlined">location_on</span>
        <div class="stack">
          <span class="label">Live count</span>
          <span class="value" id="ff974LiveCount">0</span>
        </div>
      </div>
    </div>
  </header>

  <div id="notificationsPanel" class="notifications" role="dialog" aria-label="Notifications">
    <div class="notif-header">Notifications</div>
    <div id="notifList" class="notif-list"></div>
    <div id="notifFooter" class="notif-footer"></div>
  </div>

  <div id="chatPanel" class="chat-panel" role="dialog" aria-label="Chat">
    <div class="chat-header">
      <div class="chat-title" style="display:flex;align-items:center;gap:6px;">
        <span class="material-icons-outlined" style="font-size:14px;">chat</span>Chat
      </div>
      <div class="chat-actions">
        <button id="chatMarkReadBtn" class="chat-mark-btn" title="Mark all as read">Mark all read</button>
      </div>
    </div>
    <div id="chatList" class="chat-list" aria-live="polite"></div>
    <div class="chat-input-row">
      <input id="chatInput" class="chat-input" type="text" placeholder="Type a message..." aria-label="Type a message">
      <button id="chatSendBtn" class="send-btn" title="Send" aria-label="Send">
        <span class="material-icons-outlined">send</span>
      </button>
    </div>
  </div>

  <div id="map" class="map-visual-dimmer" aria-label="Distribution Map"></div>

  <div id="proofStrip" class="proof-strip" aria-label="Proofs slider">
    <button id="psLeft" class="ps-btn" title="Scroll left" aria-label="Scroll left">
      <span class="material-icons-outlined">chevron_left</span>
    </button>
    <div id="proofStripInner" class="proof-strip-inner"></div>
    <button id="psRight" class="ps-btn" title="Scroll right" aria-label="Scroll right">
      <span class="material-icons-outlined">chevron_right</span>
    </button>
  </div>

  <footer class="footer" id="footer">
    <div>click on any zone to view details</div>
  </footer>

  <div id="imgModal" class="modal" aria-modal="true" role="dialog">
    <div class="modal-content img-modal">
      <button id="modalCloseBtn" class="modal-close" aria-label="Close preview">&times;</button>
      <img id="modalImg" alt="Proof preview" loading="lazy" decoding="async">
    </div>
  </div>

  <!-- Scripts: defer for faster first paint -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js" defer></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, onValue, get, update, push, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

    /* Firebase Configs */
    const campaignFirebaseConfig = {
      apiKey:"AIzaSyD_c9jMxAA6dtyk_EXAHnH09OEAoalUADA",
      authDomain:"trackingclients.firebaseapp.com",
      projectId:"trackingclients",
      storageBucket:"trackingclients.appspot.com",
      messagingSenderId:"27490943622",
      appId:"1:27490943622:web:d6c87547aa5df440508707",
      databaseURL:"https://trackingclients-default-rtdb.firebaseio.com/"
    };
    const polygonsFirebaseConfig = {
      apiKey: "AIzaSyBHRyOy3hNcWarK8Zk34MWrv_tIYKM7mXM",
      authDomain: "leuvenflyers-23584.firebaseapp.com",
      databaseURL: "https://leuvenflyers-23584-default-rtdb.firebaseio.com",
      projectId: "leuvenflyers-23584",
      storageBucket: "leuvenflyers-23584.firebasestorage.app",
      messagingSenderId: "1077790950414",
      appId: "1:1077790950414:web:036fafe06df86f41ed285f"
    };
    const ff974FirebaseConfig = {
      apiKey: "AIzaSyBuBB-Cha7eLG1O7SxOTfFt8e6hVAWjkxI",
      authDomain: "tokentransfer-4a9b3.firebaseapp.com",
      databaseURL: "https://tokentransfer-4a9b3-default-rtdb.firebaseio.com",
      projectId: "tokentransfer-4a9b3",
      storageBucket: "tokentransfer-4a9b3.firebasestorage.app",
      messagingSenderId: "205455490321",
      appId: "1:205455490321:web:9919f5dde059316c9320b0"
    };

    const campaignApp = initializeApp(campaignFirebaseConfig, 'campaignApp');
    const db = getDatabase(campaignApp);

    const polygonsApp = initializeApp(polygonsFirebaseConfig,'polygonsApp');
    const polygonsDb = getDatabase(polygonsApp);

    const ff974App = initializeApp(ff974FirebaseConfig, 'ff974App');
    const ff974Db = getDatabase(ff974App);

    /* DOM Elements */
    const flyersTotalEl = document.getElementById('flyersTotal');
    const flyersDistributedEl = document.getElementById('flyersDistributed');
    const qrScanCountEl = document.getElementById('qrScanCount');
    const qrCounter = document.getElementById('qrCounter');
    const notifBtn = document.getElementById('notifBtn');
    const notifPanel = document.getElementById('notificationsPanel');
    const notifList = document.getElementById('notifList');
    const notifBadge = document.getElementById('notifBadge');
    const notifFooter = document.getElementById('notifFooter');
    const topbar = document.getElementById('topbar');
    const mapEl = document.getElementById('map');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const recentBtn = document.getElementById('recentBtn');
    const proofStrip = document.getElementById('proofStrip');
    const proofStripInner = document.getElementById('proofStripInner');
    const psLeft = document.getElementById('psLeft');
    const psRight = document.getElementById('psRight');
    const flyersRequiredEl = document.getElementById('flyersRequired');
    const zoneProgressEl = document.getElementById('zoneProgress');
    const impressionsTotalEl = document.getElementById('impressionsTotal');
    const footerEl = document.getElementById('footer');

    const ff974LiveCountEl = document.getElementById('ff974LiveCount');

    const chatBtn = document.getElementById('chatBtn');
    const chatPanel = document.getElementById('chatPanel');
    const chatListEl = document.getElementById('chatList');
    const chatInputEl = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatBadge = document.getElementById('chatBadge');
    const chatMarkReadBtn = document.getElementById('chatMarkReadBtn');

    /* State */
    const TOTAL_FLYERS = 5000;
    flyersTotalEl.textContent = TOTAL_FLYERS.toLocaleString();

    let map;
    let polygonLayers = [];
    let labelMarkers = [];
    let labelMarkersByZone = new Map();
    let polygonMeta = [];
    let polygonsByZone = new Map();

    let proofMarkers = [];
    let proofMarkersById = new Map();
    let proofsList = [];
    let notificationsArr = [];

    const ZONE_STATUS_PATH = 'campaigns/XX2602/zone_statuses';
    const zoneStatusByZone = new Map();
    const zoneStatusKeyByZone = new Map();

    let firstFullLoad = true;
    let viewCalculationInterval = null;

    // Building data cache
    const buildingDataByZone = new Map();
    const buildingFetchPromises = new Map();
    let currentBuildingLayerGroup = null;
    let buildingLayerZone = null;

    // Chat state
    const CHAT_PATH = 'campaigns/XX2602/chat/messages';
    let chatMessages = [];
    let chatInitialized = false;
    const deviceIdKey = 'XX2602_chat_device_id';
    const myDeviceId = getOrCreateDeviceId();
    const myName = 'Viewer';
    const lastReadKey = 'XX2602_chat_last_read_ts';

    // FF2602 dots (blue circles)
    const FF2602_USER = 'FF2602';
    let ff974DotsLayer = null;
    let ff974DotsPolyline = null;

    // latest focus tracking
    let lastLatestFocusedZone = null;
    let lastLatestFocusTs = 0;

    // Network conditions
    try {
      const conn = navigator.connection || navigator.webkitConnection || navigator.mozConnection;
      if (conn && (conn.saveData || ['slow-2g','2g'].includes(conn.effectiveType))) {
        document.body.classList.add('reduced-motion');
      }
    } catch {}

    const idle = (fn) => {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => fn(), { timeout: 400 });
      } else {
        setTimeout(fn, 0);
      }
    };

    async function waitForGlobals(keys, timeoutMs = 6000){
      const start = Date.now();
      return new Promise((resolve, reject) => {
        (function check(){
          const ok = keys.every(k => !!window[k]);
          if (ok) return resolve();
          if (Date.now() - start > timeoutMs) return reject(new Error('Libraries failed to load in time'));
          setTimeout(check, 20);
        })();
      });
    }

    function setHeaderHeightVar(){
      const h = topbar.getBoundingClientRect().height;
      document.documentElement.style.setProperty('--topbar-total-height', h + 'px');
      mapEl.style.top = h + 'px';
      notifPanel.style.top = (h + 6) + 'px';
      chatPanel.style.top = (h + 6) + 'px';
    }
    new ResizeObserver(() => requestAnimationFrame(setHeaderHeightVar)).observe(topbar);
    window.addEventListener('orientationchange', () => setTimeout(setHeaderHeightVar, 150), { passive: true });
    window.addEventListener('resize', () => setHeaderHeightVar(), { passive: true });

    // SAFETY: hide loader on any uncaught error so app never stays stuck
    window.addEventListener('error', () => {
      try { hideLoader(); } catch {}
      try { footerEl.innerHTML = '<div style="color: var(--danger);">An error occurred. Please refresh.</div>'; } catch {}
    });

    // SAFETY: fallback to hide loader after 8s even if something took too long
    setTimeout(() => {
      const ov = document.getElementById('loadingOverlay');
      if (ov && !ov.classList.contains('fade-out')) hideLoader();
    }, 8000);

    function addNotification(icon, message, key, timestamp = Date.now()){
      if(key && notificationsArr.some(n=>n.key===key)) return;
      const zMatch = /Zone\s+(\d+)/i.exec(message);
      const zone = zMatch? parseInt(zMatch[1],10) : null;
      notificationsArr.push({
        key: key || ('k_'+timestamp+'_'+Math.random().toString(36).slice(2)),
        icon, message, zone, ts: timestamp
      });
      notificationsArr.sort((a, b) => b.ts - a.ts);
      renderNotifications();
    }
    function renderNotifications(){
      notifList.innerHTML='';
      if(!notificationsArr.length){
        notifList.innerHTML='<div class="notif-empty">No notifications yet.</div>';
        notifFooter.textContent='';
        notifBadge.style.display='none';
        notifPanel.classList.remove('scroll-after-4');
        return;
      }
      const frag = document.createDocumentFragment();
      notificationsArr.slice(0,40).forEach(n=>{
        const item=document.createElement('div');
        item.className='notif-item';
        if(n.zone) item.dataset.zone = n.zone;
        item.innerHTML=`
          <div class="notif-icon"><span class="material-icons-outlined">${n.icon}</span></div>
          <div class="notif-msg">${n.message}</div>`;
        item.addEventListener('click',()=>{
          if(n.zone) focusZone(n.zone);
          notifPanel.style.display='none';
        }, { passive: true });
        frag.appendChild(item);
      });
      notifList.appendChild(frag);
      notifBadge.textContent=notificationsArr.length;
      notifBadge.style.display='inline-block';
      notifFooter.textContent=`${notificationsArr.length} notifications`;
      if(notificationsArr.length > 4){
        notifPanel.classList.add('scroll-after-4');
      } else {
        notifPanel.classList.remove('scroll-after-4');
      }
    }
    notifBtn.addEventListener('click',e=>{
      e.stopPropagation();
      notifPanel.style.display = notifPanel.style.display === 'flex' ? 'none' : 'flex';
      if (notifPanel.style.display === 'flex') {
        setHeaderHeightVar();
        renderNotifications();
      }
    });
    document.addEventListener('click',e=>{
      if(!notifPanel.contains(e.target) && !notifBtn.contains(e.target)){
        notifPanel.style.display='none';
      }
      if(!chatPanel.contains(e.target) && !chatBtn.contains(e.target)){
        chatPanel.style.display='none';
      }
    }, { passive: true });

    document.addEventListener('DOMContentLoaded', async ()=>{
      setHeaderHeightVar();

      try { await waitForGlobals(['L', 'turf']); } catch (err) { console.error('Libraries not ready:', err); }

      // Leaflet: smooth zoom and wheel behavior
      map = L.map('map', {
        preferCanvas: true,
        zoomControl: true,
        attributionControl: false,
        zoomSnap: 0.25,
        zoomDelta: 0.25,
        wheelDebounceTime: 15,
        wheelPxPerZoomLevel: 200,
        inertia: true,
        inertiaDeceleration: 2500,
        fadeAnimation: true,
        zoomAnimation: true,
        easeLinearity: 0.2
      }).setView([50.85,4.35],13);

      L.tileLayer(
        'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        {
          maxZoom: 20,
          attribution: '&copy; OpenStreetMap & CARTO',
          updateWhenZooming: false,
          updateWhenIdle: true,
          keepBuffer: 1,
          detectRetina: false,
          crossOrigin: true
        }
      ).addTo(map);

      ff974DotsLayer = L.layerGroup().addTo(map);

      try {
        await loadPolygons();
        listenZoneStatuses();
        listenProofs();
        listenQrScans();
        listenChat();
        listenFF2602Dots();

        if (viewCalculationInterval) clearInterval(viewCalculationInterval);
        viewCalculationInterval = setInterval(updateViewingZones, 4000);
      } catch (error) {
        console.error("Failed to initialize application:", error);
        footerEl.innerHTML = `<div style="color: var(--danger);">Could not load map data. Please refresh.</div>`;
      } finally {
        hideLoader();
      }
    });

    async function loadPolygons(){
      const snap = await get(ref(polygonsDb,'polygons'));
      if(!snap.exists()) { 
        throw new Error("No polygons found in the database.");
      }

      polygonLayers.forEach(p=>map.removeLayer(p));
      labelMarkers.forEach(m=>map.removeLayer(m));
      polygonLayers=[];labelMarkers=[];labelMarkersByZone.clear();polygonMeta=[];polygonsByZone.clear();
      let allCoords=[];

      snap.forEach(child=>{
        const raw = child.val();
        if(!raw || typeof raw!=='object') return;
        const coordsArr = Object.keys(raw)
          .filter(k => !isNaN(Number(k)))
          .sort((a,b)=>Number(a)-Number(b))
          .map(k => {
            const pt=raw[k];
            return Array.isArray(pt) && pt.length===2
              ? [pt[0], pt[1]]
              : [pt.lat, pt.lng];
          })
          .filter(pt => Array.isArray(pt) && typeof pt[0]==='number' && typeof pt[1]==='number');
        if(!coordsArr.length) return;

        let zoneNum = raw.zoneNumber;
        if(zoneNum===undefined || zoneNum===null || zoneNum===''){
          zoneNum = polygonLayers.length + 1;
        } else {
          zoneNum = parseInt(zoneNum,10);
          if(isNaN(zoneNum)) zoneNum = polygonLayers.length + 1;
        }

        const poly=L.polygon(coordsArr,{
          color:'#1976d2',
          weight:1,
          fillColor:'#2196f3',
          fillOpacity:.2,
          renderer: map.options.preferCanvas ? map._renderer : undefined
        }).addTo(map);

        poly.bindPopup(`<div style="font-size:11px;">Zone ${zoneNum}<br/>Loading...</div>`);

        const index = polygonLayers.length;
        polygonLayers.push(poly);
        polygonsByZone.set(zoneNum, index);

        const areaSqM = computeAreaSqM(coordsArr);
        const isTiny = areaSqM < 250;

        const bounds = poly.getBounds();
        const ringLngLat = coordsArr.map(([lat,lng]) => [lng, lat]);
        const firstRing = ringLngLat[0];
        if(firstRing && (ringLngLat[ringLngLat.length-1][0] !== firstRing[0] || ringLngLat[ringLngLat.length-1][1] !== firstRing[1])){
          ringLngLat.push([firstRing[0], firstRing[1]]);
        }
        const turfPoly = turf.polygon([ringLngLat]);

        polygonMeta.push({layer:poly, zoneNumber:zoneNum, isTiny, bounds, turfPoly});

        allCoords = allCoords.concat(coordsArr);

        const center=poly.getBounds().getCenter();
        const label=L.marker(center,{
          icon:L.divIcon({
            className:'zone-label-wrapper',
            html:zoneNumberLabelHtml(zoneNum, isTiny, '', false, 0),
            iconSize:[34,24],
            iconAnchor:[17,12]
          }),
          interactive:true
        }).addTo(map);

        label.on('click', () => { try { poly.openPopup(); } catch(e){} });

        labelMarkers.push(label);
        labelMarkersByZone.set(zoneNum, label);
      });
      if(allCoords.length){
        map.fitBounds(L.latLngBounds(allCoords).pad(0.12), { animate: true });
      }
    }

    function computeAreaSqM(latlngPairs){
      try{
        if(!Array.isArray(latlngPairs) || latlngPairs.length < 3) return 0;
        const ring = latlngPairs.map(([lat, lng]) => [lng, lat]);
        const first = ring[0], last = ring[ring.length-1];
        if(first[0] !== last[0] || first[1] !== last[1]){
          ring.push([first[0], first[1]]);
        }
        const poly = turf.polygon([ring]);
        const area = turf.area(poly);
        return Number.isFinite(area) ? area : 0;
      }catch(err){
        console.error('Area compute failed', err);
        return 0;
      }
    }

    function getStatusClass(status, fullyViewed){
      if(fullyViewed) return 'status-fully-viewed';
      if(status==='booked') return 'status-booked';
      if(status==='completed') return 'status-completed';
      return '';
    }

    // Label builder: show flyers badge with mail icon on completed zones only
    function zoneNumberLabelHtml(z, tiny=false, status='', fullyViewed = false, flyersCount = 0){
      const statusClass = getStatusClass(status, fullyViewed);
      const classes = ['zone-label'];
      if(tiny) classes.push('tiny');
      if(statusClass) classes.push(statusClass);

      const flyersHtml = status==='completed' && flyersCount>0
        ? `<span class="flyers-badge" title="Flyers reported"><span class="material-icons-outlined">mail</span>${flyersCount}</span>`
        : '';

      return `<div class="${classes.join(' ')}"><span class="zone-num">${z}</span>${flyersHtml}</div>`;
    }

    function safeInt(v){const n=parseInt(v);return isNaN(n)?0:n;}
    function statusMeta(status, fullyViewed){
      if(fullyViewed) return {text:'Fully Viewed', color: '#31A24C', icon:'visibility'};
      switch(status){
        case 'completed': return {text:'Done',color:'#2e7d32',icon:'task_alt'};
        case 'inprogress': return {text:'Active',color:'#F5C33B',icon:'play_arrow'};
        case 'booked': return {text:'Booked',color:'#F5C33B',icon:'bookmark_added'};
        default: return {text:'Pending',color:'#d32f2f',icon:'hourglass_empty'};
      }
    }

    function listenZoneStatuses(){
      onValue(ref(db, ZONE_STATUS_PATH), snap=>{
        let newlyCompletedZones = [];
        const existingCompleted = new Set();
        zoneStatusByZone.forEach((status, zoneNum) => {
          if (status.status === 'completed') existingCompleted.add(zoneNum);
        });

        zoneStatusByZone.clear();
        zoneStatusKeyByZone.clear();
        if(snap.exists()){
          snap.forEach(child=>{
            const key = child.key;
            const data = child.val() || {};
            const fieldZone = safeInt(data.zoneNumber);
            const keyNum = safeInt(key);
            let zNum = null;
            if(fieldZone && polygonsByZone.has(fieldZone)) zNum = fieldZone;
            else if(keyNum && polygonsByZone.has(keyNum)) zNum = keyNum;
            else if((keyNum || key==='0') && polygonsByZone.has(keyNum+1)) zNum = keyNum+1;
            else if(safeInt(data.zone) && polygonsByZone.has(safeInt(data.zone))) zNum = safeInt(data.zone);
            if(zNum!=null){
              if (data.status === 'completed' && !existingCompleted.has(zNum)) {
                data.completedAt = data.completedAt || Date.now();
                newlyCompletedZones.push({zoneNum: zNum, timestamp: data.completedAt});
              }
              zoneStatusByZone.set(zNum,data);
              zoneStatusKeyByZone.set(zNum,key);
            }
          });
        }

        newlyCompletedZones.forEach(({zoneNum, timestamp}) => {
          addNotification('task_alt', `Zone ${zoneNum} completed!`, `zone-${zoneNum}-done`, timestamp);
        });

        idle(updateZonesVisual);

        if (firstFullLoad) {
          firstFullLoad = false;
          const lastCompleted = newlyCompletedZones.sort((a,b) => b.timestamp - a.timestamp)[0];
          if (lastCompleted) {
            setTimeout(() => focusZone(lastCompleted.zoneNum), 250);
          }
        } else if (newlyCompletedZones.length > 0) {
          const lastCompleted = newlyCompletedZones.sort((a,b) => b.timestamp - a.timestamp)[0];
          if (lastCompleted) focusZone(lastCompleted.zoneNum);
        }
      });
    }

    function updateZonesVisual(){
      let distributed=0;
      let bookedCount = 0;
      let completedCount = 0;
      let totalCurrentImpressions = 0;
      let totalPossibleImpressions = 0;

      polygonMeta.forEach(({layer:poly, zoneNumber:zoneNum, isTiny})=>{
        const z = zoneStatusByZone.get(zoneNum) || {};
        const flyers = safeInt(z.flyers);
        const impressionInfo = calculateImpressionProgress(z);
        totalCurrentImpressions += impressionInfo.current;
        totalPossibleImpressions += impressionInfo.total;

        if(z.status === 'booked') bookedCount++;
        if(z.status === 'completed') completedCount++;
        if(z.status==='completed') distributed+=flyers;

        const meta=statusMeta(z.status, impressionInfo.fullyViewed);

        // Polygon fill reflects status (yellow when booked)
        poly.setStyle({
          fillColor: meta.color,
          fillOpacity: impressionInfo.isViewing ? (poly.options.fillOpacity || 0.22) : 0.28,
          color: z.status==='booked' ? '#b38700' : '#1976d2',
          weight: 1,
          dashArray: null
        });

        const canBook = z.status !=='booked' && z.status !=='completed';
        const canUnbook = z.status === 'booked';
        let actionButtonsHtml = '';

        if(canBook) {
          actionButtonsHtml += `<button class="zp-btn warn" data-act="book" data-zone="${zoneNum}" data-ready="false"><span class="material-icons-outlined" style="font-size:14px;">bookmark_add</span>Book</button>`;
        }
        if(canUnbook) {
          actionButtonsHtml += `<button class="zp-btn danger" data-act="unbook" data-zone="${zoneNum}"><span class="material-icons-outlined" style="font-size:14px;">bookmark_remove</span>Unbook</button>`;
        }
        if (z.status === 'completed') {
          if (z.verifiedAt) {
            actionButtonsHtml += `<button class="zp-btn" disabled><span class="material-icons-outlined" style="font-size:14px;">verified</span>Verified</button>`;
          } else {
            actionButtonsHtml += `<button class="zp-btn verify-btn" data-act="verify" data-zone="${zoneNum}"><span class="material-icons-outlined" style="font-size:14px;">check_circle</span>Verify</button>`;
          }
        }

        let impressionHTML = '';
        if (z.verifiedAt) {
          impressionHTML = `
            <div style="margin-top:4px;color:#2f4451;font-size:11px;">
              <span style="display:inline-flex;align-items:center;gap:4px;">
                <span class="material-icons-outlined" style="font-size:12px;color:#1877F2;">visibility</span>
                Impressions: <strong>${impressionInfo.current.toLocaleString()} / ${impressionInfo.total.toLocaleString()}</strong>
              </span>
            </div>
            <div style="margin-top:4px;color:#2f4451;font-size:11px;">
              <span style="display:inline-flex;align-items:center;gap:4px;">
                <span class="material-icons-outlined" style="font-size:12px;color:#8A8D91;">today</span>
                Days Passed: <strong>${impressionInfo.daysPassed} / 7</strong>
              </span>
            </div>`;
        }

        let flyersRequiredHTML = '';
        if (z.flyersRequired) {
          flyersRequiredHTML = `
            <div style="margin-top:4px;color:#2f4451;font-size:11px;">
              <span style="display:inline-flex;align-items:center;gap:4px;">
                <span class="material-icons-outlined" style="font-size:12px;color:var(--warning);">group</span>
                Flyers Required: <strong>${z.flyersRequired.toLocaleString()}</strong>
              </span>
            </div>`;
        }

        const helpNote = canBook ? `<div class="mini-hint" style="margin-top:8px;color:#5b6872;">Loading building dots for this zone… Booking will be enabled once dots are visible.</div>` : '';

        let popupHTML=`
          <div style="text-align:left;">
            <strong style="display:flex;justify-content:flex-start;align-items:center;gap:4px;color:#0e3450;font-size:12px;">
              <span class="material-icons-outlined" style="font-size:14px;color:#1976d2;">layers</span>
              Zone ${zoneNum}
            </strong>
            <div style="margin-top:6px;color:#2f4451;font-size:11px;">
              <span style="display:inline-flex;align-items:center;gap:4px;">
                <span class="material-icons-outlined" style="font-size:12px;color:#1976d2;">mail</span>
                Flyers (reported): <strong>${flyers || '-'}</strong>
              </span>
            </div>
            ${flyersRequiredHTML}
            ${impressionHTML}
            <div style="margin-top:4px;color:#2f4451;font-size:11px;">
              <span style="display:inline-flex;align-items:center;gap:4px;">
                <span class="material-icons-outlined" style="font-size:12px;color:${meta.color};">info</span>
                Status: <strong>${meta.text}</strong>
              </span>
            </div>
            ${helpNote}
            <div style="margin-top: 8px; display: flex; gap: 6px;">${actionButtonsHtml}</div>
          </div>
        `;
        if(z.gpsProof || z.gpsUrl){
          popupHTML+=`<div style="margin-top:8px;"><a href="${z.gpsProof||z.gpsUrl}" target="_blank" rel="noopener"
                 style="background:#1976d2;color:#fff;font-size:10px;padding:5px 12px;border-radius:10px;
                 display:inline-flex;align-items:center;gap:6px;text-decoration:none;">
                <span class="material-icons-outlined" style="font-size:14px;">assistant_navigation</span>GPS Route
              </a></div>`;
        }
        if(z.proofImage){
          popupHTML+=`<div style="margin-top:10px;"><img src="${z.proofImage}" alt="Proof" class="popup-img-thumb" data-proof="${z.proofImage}"
                loading="lazy" decoding="async"
                style="max-width:110px;border-radius:10px;cursor:pointer;border:1px solid #d9e2e8;"></div>`;
        }

        poly.bindPopup(popupHTML);

        const label = labelMarkersByZone.get(zoneNum);
        if(label){
          label.setIcon(L.divIcon({
            className:'zone-label-wrapper',
            html: zoneNumberLabelHtml(zoneNum, isTiny, z.status || '', impressionInfo.fullyViewed, flyers),
            iconSize:[34,24],
            iconAnchor:[17,12]
          }));
        }

        poly.off('popupopen');
        poly.on('popupopen', evt=>{
          const popupEl = evt.popup?.getElement?.();
          if(!popupEl) return;

          const img = popupEl.querySelector('.popup-img-thumb[data-proof]');
          if(img) img.addEventListener('click',()=>showModal('imgModal', img.getAttribute('data-proof')), { passive: true });

          // Preload building dots for PENDING zones; enable booking only after visible
          const statusObj = zoneStatusByZone.get(zoneNum) || {};
          const bookBtn = popupEl.querySelector('.zp-btn[data-act="book"][data-zone="'+zoneNum+'"]');

          if (bookBtn) {
            // Disable until visible
            bookBtn.disabled = true;
            bookBtn.textContent = 'Loading buildings…';
            ensureBuildingDotsLoaded(zoneNum, poly)
              .then(ok => {
                if (ok) {
                  bookBtn.disabled = false;
                  bookBtn.dataset.ready = 'true';
                  bookBtn.innerHTML = `<span class="material-icons-outlined" style="font-size:14px;">bookmark_add</span>Book`;
                } else {
                  bookBtn.disabled = false;
                  bookBtn.dataset.ready = 'false';
                  bookBtn.innerHTML = `Retry loading`;
                }
              });

            bookBtn.addEventListener('click', async e => {
              e.preventDefault(); e.stopPropagation();
              // Allow booking only if building dots are visible
              const ready = bookBtn.dataset.ready === 'true' && currentBuildingLayerGroup && buildingLayerZone === zoneNum;
              if (!ready) {
                alert('Building dots are not visible yet. Please try again after they load.');
                return;
              }
              bookBtn.disabled = true;
              bookBtn.textContent = 'Booking…';
              try {
                await applyStatusToZones([zoneNum], 'booked');
              } catch (err) {
                console.error('Booking failed', err);
                alert('Failed to book. Please try again.');
                bookBtn.disabled = false;
                bookBtn.innerHTML = `<span class="material-icons-outlined" style="font-size:14px;">bookmark_add</span>Book`;
                return;
              }
              poly.closePopup();
            });
          }

          // Other actions
          popupEl.querySelectorAll('.zp-btn[data-act]').forEach(btn => {
            if (btn.dataset.act === 'book') return; // handled above
            btn.addEventListener('click', async e => {
              e.preventDefault(); e.stopPropagation();
              const act = btn.dataset.act;
              const znum = parseInt(btn.dataset.zone, 10);
              btn.disabled = true;
              btn.textContent = 'Working…';

              if (act === 'verify') {
                await verifyZone(znum);
              } else if (act === 'unbook') {
                await applyStatusToZones([znum], 'pending');
              }
              poly.closePopup();
            });
          });
        });
      });
      flyersDistributedEl.textContent = distributed.toLocaleString();
      zoneProgressEl.textContent = `${bookedCount}B / ${completedCount}C`;
      impressionsTotalEl.textContent = `${totalCurrentImpressions.toLocaleString()} / ${totalPossibleImpressions.toLocaleString()}`;
      recalcFlyersRequiredTotal();
    }

    async function verifyZone(zoneNum) {
      const key = zoneStatusKeyByZone.get(zoneNum);
      if (!key) {
        console.error("Could not find key for zone", zoneNum);
        return;
      }
      const zoneRef = ref(db, `${ZONE_STATUS_PATH}/${key}`);
      try {
        await update(zoneRef, { verifiedAt: serverTimestamp() });
        addNotification('verified', `Zone ${zoneNum} has been verified for impressions.`, `zone-verified-${zoneNum}`);
      } catch (err) {
        console.error("Failed to verify zone:", err);
        alert("Could not verify zone. Please try again.");
      }
    }

    function focusRecentCompletedZones(onlyLast=true){
      const completed = [];
      zoneStatusByZone.forEach((z, zoneNum) => {
        if (z.status === 'completed' && z.completedAt) {
          completed.push({zoneNum, ts: z.completedAt});
        }
      });
      if (!completed.length) return;
      completed.sort((a,b) => b.ts - a.ts);
      if (onlyLast) {
        focusZone(completed[0].zoneNum);
      }
    }

    // Smooth focus: fitBounds + flyTo with moderate duration
    window.focusZone = function(zoneNum){
      const idx = polygonsByZone.get(zoneNum);
      if(idx===undefined) return;
      const poly = polygonLayers[idx];
      if(!poly) return;
      const bounds=poly.getBounds();
      map.fitBounds(bounds.pad(0.26), { animate: true });
      setTimeout(()=>{
        const center = bounds.getCenter();
        const targetZoom = Math.max(map.getZoom(), 15);
        map.flyTo(center, targetZoom, { duration: 0.6, easeLinearity: 0.2 });
        poly.openPopup();
      },220);
    };
    recentBtn.addEventListener('click',()=>focusRecentCompletedZones(true));

    async function applyStatusToZones(zones, newStatus){
      if(!zones.length) return;
      const updates = {};
      zones.forEach(zoneNum=>{
        let nodeKey = zoneStatusKeyByZone.get(zoneNum) || String(zoneNum);
        updates[`${nodeKey}/status`] = newStatus;
        updates[`${nodeKey}/zoneNumber`] = zoneNum;
        if (newStatus === 'completed') {
          updates[`${nodeKey}/completedAt`] = serverTimestamp();
        }
      });
      await update(ref(db, ZONE_STATUS_PATH), updates);

      // When booking, compute flyersRequired from buildings (keep feature)
      if(newStatus==='booked'){
        for(const z of zones){
          const statusObj = zoneStatusByZone.get(z) || {};
          if(typeof statusObj.flyersRequired === 'number'){ continue; }
          const poly = polygonLayers[polygonsByZone.get(z)];
          if(poly){
            try{
              const count = await computeBuildingCount(z, poly);
              const required = count * 2;
              const nodeKey = zoneStatusKeyByZone.get(z) || String(z);
              await update(ref(db, `${ZONE_STATUS_PATH}/${nodeKey}`), { flyersRequired: required });
            }catch(err){
              console.error('Failed to compute flyersRequired for zone', z, err);
            }
          }
        }
      }
    }

    function recalcFlyersRequiredTotal(){
      let total=0;
      zoneStatusByZone.forEach(z=>{
        if(z.status==='booked' && z.flyersRequired){
          total += safeInt(z.flyersRequired);
        }
      });
      flyersRequiredEl.textContent = total.toLocaleString();
    }

    function getPrimaryRingLatLngs(poly){
      let latlngs = poly.getLatLngs();
      if(Array.isArray(latlngs[0])) latlngs = latlngs[0];
      return latlngs;
    }

    const IMPRESSION_MULTIPLIER = 1.5;
    const TOTAL_DAYS = 7;
    const TOTAL_MS = TOTAL_DAYS * 24 * 60 * 60 * 1000;

    function calculateImpressionProgress(zoneStatus) {
      const result = { total: 0, current: 0, daysPassed: 0, fullyViewed: false, isViewing: false };
      if (zoneStatus.status !== 'completed' || !zoneStatus.verifiedAt) return result;

      const totalPossible = Math.floor((zoneStatus.flyers || 0) * IMPRESSION_MULTIPLIER);
      result.total = totalPossible;

      const now = Date.now();
      const timeSinceVerification = now - zoneStatus.verifiedAt;

      if (timeSinceVerification < 0) return result;

      let currentImpressions = 0;
      if (timeSinceVerification < TOTAL_MS) {
        const progress = timeSinceVerification / TOTAL_MS;
        currentImpressions = totalPossible * progress;
        result.isViewing = true;
      } else {
        currentImpressions = totalPossible;
        result.fullyViewed = true;
      }
      result.current = Math.floor(currentImpressions);
      result.daysPassed = Math.min(TOTAL_DAYS, Math.floor(timeSinceVerification / (1000 * 60 * 60 * 24)));

      return result;
    }

    function updateViewingZones() {
      let needsVisualUpdate = false;
      let totalCurrentImpressions = 0;
      let totalPossibleImpressions = 0;

      zoneStatusByZone.forEach((status) => {
        const impressionInfo = calculateImpressionProgress(status);
        totalCurrentImpressions += impressionInfo.current;
        totalPossibleImpressions += impressionInfo.total;

        if (status.status === 'completed' && status.verifiedAt) {
          const oldFullyViewed = status.fullyViewed || false;
          status.fullyViewed = impressionInfo.fullyViewed;
          status.isViewing = impressionInfo.isViewing;
          if (oldFullyViewed !== impressionInfo.fullyViewed) {
            needsVisualUpdate = true;
          }
        }
      });

      impressionsTotalEl.textContent = `${totalCurrentImpressions.toLocaleString()} / ${totalPossibleImpressions.toLocaleString()}`;
      if (needsVisualUpdate) idle(updateZonesVisual);
    }

    function formatDateTime(ts){
      if (!ts) return '';
      const d=new Date(ts);
      const p=n=>String(n).padStart(2,'0');
      return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`;
    }

    function showModal(modalId, imgUrl){
      const modal = document.getElementById(modalId);
      if(!modal) return;
      if(modalId === 'imgModal'){
        const img = document.getElementById('modalImg');
        if(img) img.src = imgUrl || '';
      }
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
    function hideModal(modalId) {
      const modal = document.getElementById(modalId);
      if (!modal) return;
      modal.style.display = 'none';
      if (modalId === 'imgModal') {
        document.getElementById('modalImg').src = '';
      }
      const anyModalOpen = Array.from(document.querySelectorAll('.modal')).some(m => m.style.display === 'flex');
      if (!anyModalOpen) {
        document.body.style.overflow='';
      }
    }

    document.getElementById('modalCloseBtn').addEventListener('click', () => hideModal('imgModal'));
    document.getElementById('imgModal').addEventListener('click', e => { if(e.target.id === 'imgModal') hideModal('imgModal'); }, { passive: true });
    document.addEventListener('keydown', e => { if(e.key==='Escape') { hideModal('imgModal'); }});

    function hideLoader(){
      if(!loadingOverlay) return;
      if (loadingOverlay.classList.contains('fade-out')) return;
      loadingOverlay.classList.add('fade-out');
      setTimeout(()=>loadingOverlay.remove(), 200);
    }

    // Photo proofs: show camera icons
    function listenProofs(){
      onValue(ref(db,'campaigns/XX2602/proofs'), snap=>{
        if (proofMarkers.length) {
          proofMarkers.forEach(m=>map.removeLayer(m));
          proofMarkers=[]; proofMarkersById.clear();
        }
        proofsList=[];
        const val=snap.val();
        if(val){
          for(const id in val){
            const p=val[id];
            if(typeof p.lat==='number' && typeof p.lng==='number' && p.url){
              proofsList.push({id,url:p.url,lat:p.lat,lng:p.lng,timestamp:p.timestamp||0});
            }
          }
        }
        proofsList.sort((a,b)=>(b.timestamp||0)-(a.timestamp||0));
        proofsList.forEach(p=>{
          const marker = L.marker([p.lat,p.lng], { icon: L.divIcon({
            className: 'proof-icon',
            html: '<span class="material-icons-outlined">photo_camera</span>',
            iconSize: [26,26],
            iconAnchor: [13,13]
          }) }).addTo(map);
          marker.bindPopup(`
            <div style="text-align:left;">
              <img src="${p.url}" class="popup-img-thumb" data-proof="${p.url}" loading="lazy" decoding="async" style="max-width:120px;border-radius:10px;border:1px solid #d9e2e8;cursor:pointer;" alt="Proof">
              ${p.timestamp?`<div style="margin-top:6px;font-size:10px;color:#4a5d69;display:flex;gap:4px;align-items:center;">
                <span class="material-icons-outlined" style="font-size:12px;color:#1976d2;">schedule</span>${""}
              </div>`:''}
            </div>`);
          marker.on('popupopen',()=>{
            setTimeout(()=>{
              const img=document.querySelector('.leaflet-popup .popup-img-thumb[data-proof]');
              if(img) img.addEventListener('click',()=>showModal('imgModal', img.getAttribute('data-proof')), { passive: true });
            },50);
          });
          proofMarkers.push(marker);
          proofMarkersById.set(p.id,marker);
        });
        renderProofSlider();
      });
    }

    function renderProofSlider(){
      proofStripInner.innerHTML='';
      if(!proofsList.length){ proofStrip.classList.remove('visible'); return; }
      proofStrip.classList.add('visible');
      const frag = document.createDocumentFragment();
      proofsList.forEach((p,idx)=>{
        const div=document.createElement('div');
        div.className='proof-item';
        div.dataset.id=p.id;
        div.title=p.timestamp?formatDateTime(p.timestamp):'Proof';
        div.innerHTML=`
          <img class="proof-thumb" src="${p.url}" alt="Proof ${idx+1}" loading="lazy" decoding="async">
          <span class="proof-badge"></span>`;
        div.addEventListener('click',()=>{
          focusProof(p.id);
          setSelectedProof(p.id);
        });
        frag.appendChild(div);
      });
      proofStripInner.appendChild(frag);
      psLeft.onclick=()=>scrollProofs(-1);
      psRight.onclick=()=>scrollProofs(1);
    }

    function setSelectedProof(id){
      document.querySelectorAll('.proof-item').forEach(el=>{
        el.classList.toggle('selected', el.dataset.id===id);
      });
    }
    function scrollProofs(dir){
      const amt=Math.max(140, Math.floor(proofStripInner.clientWidth*0.8));
      proofStripInner.scrollBy({left:dir*amt,behavior:'smooth'});
    }
    function focusProof(id){
      const marker=proofMarkersById.get(id);
      if(!marker) return;
      const latlng = marker.getLatLng();
      map.flyTo(latlng, Math.max(map.getZoom(),16), { duration: 0.5, easeLinearity: 0.2 });
      setTimeout(()=>{ marker.openPopup(); },300);
    }

    function listenQrScans(){
      onValue(ref(db,'qr_scans'), snap=>{
        const scans=[];
        const val=snap.val();
        if(val){
          for(const k in val){
            const s=val[k];
            if(s.promoCode==='XX2602') scans.push({...s,id:k});
          }
          scans.sort((a,b)=>(a.timestamp||0)-(b.timestamp||0));
        }
        qrScanCountEl.textContent=scans.length.toString();
      });
      qrCounter.addEventListener('click',()=>{ alert('QR Scans list is only available if active for this campaign.'); });
    }

    // Building dots helpers
    function clearBuildingDots(){
      if(currentBuildingLayerGroup){
        map.removeLayer(currentBuildingLayerGroup);
        currentBuildingLayerGroup = null;
        buildingLayerZone = null;
      }
    }

    async function ensureBuildingDotsLoaded(zoneNum, poly){
      try{
        // If already cached & visible for this zone, consider OK
        const cached = buildingDataByZone.get(zoneNum);
        if (cached && cached.count > 0 && currentBuildingLayerGroup && buildingLayerZone === zoneNum) {
          return true;
        }
        clearBuildingDots();
        const count = await computeBuildingCount(zoneNum, poly);
        const data = buildingDataByZone.get(zoneNum);
        if(!data || count <= 0){ return false; }
        // Draw black dots for building centers
        currentBuildingLayerGroup = L.layerGroup();
        data.centers.forEach(c=>{
          L.circleMarker(c,{
            radius:2,
            color:'#000',
            fillColor:'#000',
            fillOpacity:0.85,
            stroke:false
          }).addTo(currentBuildingLayerGroup);
        });
        currentBuildingLayerGroup.addTo(map);
        buildingLayerZone = zoneNum;
        return true;
      }catch(err){
        console.error('ensureBuildingDotsLoaded failed', err);
        return false;
      }
    }

    async function computeBuildingCount(zoneNum, poly) {
      if (buildingDataByZone.has(zoneNum)) {
        return buildingDataByZone.get(zoneNum).count;
      }
      if (buildingFetchPromises.has(zoneNum)) {
        await buildingFetchPromises.get(zoneNum);
        return buildingDataByZone.get(zoneNum)?.count || 0;
      }

      const ring = getPrimaryRingLatLngs(poly);
      if (!ring || !ring.length) {
        buildingDataByZone.set(zoneNum, { centers: [], count: 0 });
        return 0;
      }

      const polyStr = ring.map(ll => `${ll.lat} ${ll.lng}`).join(' ');
      const query = `[out:json][timeout:25];(node["building"](poly:"${polyStr}");way["building"](poly:"${polyStr}");relation["building"](poly:"${polyStr}"););out center;`;

      const prom = fetch('https://overpass-api.de/api/interpreter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'data=' + encodeURIComponent(query)
      })
      .then(r => {
        if (!r.ok) throw new Error('Overpass API error');
        return r.json();
      })
      .then(data => {
        const elements = data?.elements || [];
        const centers = [];
        const seen = new Set();
        elements.forEach(el => {
          let lat, lon;
          if (el.type === 'node' && typeof el.lat === 'number') {
            lat = el.lat; lon = el.lon;
          } else if (el.center) {
            lat = el.center.lat; lon = el.center.lon;
          }
          if (typeof lat === 'number' && typeof lon === 'number') {
            const key = el.type + ':' + el.id;
            if (!seen.has(key)) {
              seen.add(key);
              centers.push([lat, lon]);
            }
          }
        });
        buildingDataByZone.set(zoneNum, { centers, count: centers.length });
        return centers.length;
      })
      .catch(err => {
        console.error('Building fetch failed for zone', zoneNum, err);
        buildingDataByZone.set(zoneNum, { centers: [], count: 0 });
        return 0;
      })
      .finally(() => {
        buildingFetchPromises.delete(zoneNum);
      });

      buildingFetchPromises.set(zoneNum, prom);
      return prom;
    }

    /* FF2602 dots: tiny blue circles (#1f6feb) and a blue path. Live box shows only the number. */
    function listenFF2602Dots(){
      const userPostsRef = ref(ff974Db, `userPosts/${FF2602_USER}`);
      onValue(userPostsRef, (snapshot) => {
        ff974DotsLayer.clearLayers();
        if (ff974DotsPolyline) {
          map.removeLayer(ff974DotsPolyline);
          ff974DotsPolyline = null;
        }

        const dotsList = [];
        if(snapshot.exists()){
          snapshot.forEach(child => {
            const v = child.val();
            if(!v) return;
            if(typeof v.lat !== 'number' || typeof v.lng !== 'number') return;
            const ts = typeof v.timestamp === 'number'
              ? v.timestamp
              : (typeof v.ts === 'number' ? v.ts : Date.now());
            dotsList.push({lat: v.lat, lng: v.lng, ts});
          });
        }

        dotsList.sort((a,b)=>a.ts - b.ts);

        // Draw tiny blue circles
        dotsList.forEach(dot=>{
          L.circleMarker([dot.lat, dot.lng], {
            radius: 3,
            color: '#1f6feb',
            weight: 1,
            fillColor: '#1f6feb',
            fillOpacity: 0.9
          }).addTo(ff974DotsLayer);
        });

        // Connect with a thin blue path
        if (dotsList.length >= 2) {
          const latlngs = dotsList.map(d => [d.lat, d.lng]);
          ff974DotsPolyline = L.polyline(latlngs, {
            color: '#1f6feb',
            weight: 1,
            opacity: 0.7
          }).addTo(map);
        }

        updateLatestDotUI(dotsList.length, dotsList[dotsList.length-1] || null);
      }, (err) => {
        console.error('FF2602 dots listener failed:', err);
        ff974LiveCountEl.textContent = '0';
      });
    }

    function updateLatestDotUI(totalCount, latestDot){
      const now = Date.now();
      // Optional gentle focus of latest zone (no extra text in stats)
      if(latestDot && (now - lastLatestFocusTs) > 8000){
        lastLatestFocusTs = now;
        polygonMeta.some(meta=>{
          if(meta.bounds && !meta.bounds.contains(L.latLng(latestDot.lat, latestDot.lng))) return false;
          if(meta.turfPoly && turf.booleanPointInPolygon([latestDot.lng, latestDot.lat], meta.turfPoly)){
            if (lastLatestFocusedZone !== meta.zoneNumber) {
              lastLatestFocusedZone = meta.zoneNumber;
              setTimeout(()=>focusZone(meta.zoneNumber), 120);
            }
            return true;
          }
          return false;
        });
      }
      // In live counts box, show number only
      ff974LiveCountEl.textContent = totalCount.toLocaleString();
    }

    function getOrCreateDeviceId(){
      let id = localStorage.getItem(deviceIdKey);
      if(!id){
        id = 'dev_'+Math.random().toString(36).slice(2,10)+Date.now().toString(36).slice(-4);
        localStorage.setItem(deviceIdKey, id);
      }
      return id;
    }
    function getLastReadTs(){
      const v = parseInt(localStorage.getItem(lastReadKey)||'0',10);
      return isNaN(v)?0:v;
    }
    function setLastReadTs(ts){
      localStorage.setItem(lastReadKey, String(ts||0));
      updateChatBadge();
    }
    function listenChat(){
      onValue(ref(db, CHAT_PATH), snap=>{
        chatMessages = [];
        const val = snap.val();
        if(val){
          Object.keys(val).forEach(k=>{
            const m = val[k];
            if(m && m.text){
              chatMessages.push({
                id: k,
                text: String(m.text),
                ts: typeof m.timestamp === 'number' ? m.timestamp : (m._serverTs || 0),
                authorId: m.authorId || 'unknown',
                authorName: m.authorName || 'User'
              });
            }
          });
          chatMessages.sort((a,b)=>(a.ts||0)-(b.ts||0));
        }
        renderChat();
        updateChatBadge();

        if(chatInitialized){
          const unreadFromOthers = chatMessages.filter(m=>m.authorId!==myDeviceId && m.ts > getLastReadTs());
          if(unreadFromOthers.length){
            const last = unreadFromOthers[unreadFromOthers.length-1];
            addNotification('chat', `New chat message: "${truncate(last.text, 48)}"`, `chat-last-${last.id}`);
          }
        }
        chatInitialized = true;
      });

      chatBtn.addEventListener('click', e=>{
        e.stopPropagation();
        chatPanel.style.display = chatPanel.style.display === 'flex' ? 'none' : 'flex';
        if(chatPanel.style.display === 'flex'){
          setHeaderHeightVar();
          setTimeout(()=>{ scrollChatToBottom(); chatInputEl.focus(); }, 60);
        }
      });
      chatSendBtn.addEventListener('click', sendChatMessage);
      chatInputEl.addEventListener('keydown', e=>{
        if(e.key==='Enter' && !e.shiftKey){
          e.preventDefault();
          sendChatMessage();
        }
      });
      chatMarkReadBtn.addEventListener('click', ()=>{
        const lastTs = chatMessages.length ? chatMessages[chatMessages.length-1].ts||Date.now() : Date.now();
        setLastReadTs(lastTs);
      });
    }
    function truncate(s, n){
      return (s||'').length>n ? s.slice(0,n-1)+'…' : s;
    }
    function avatarInitial(name){
      const s = (name||'U').trim();
      return (s[0]||'U').toUpperCase();
    }
    function renderChat(){
      chatListEl.innerHTML = '';
      if(!chatMessages.length){
        const empty = document.createElement('div');
        empty.style.cssText='padding:6px 8px;color:#667883;font-size:11px;text-align:center;';
        empty.textContent = 'No messages yet. Start the conversation!';
        chatListEl.appendChild(empty);
        return;
      }
      const frag = document.createDocumentFragment();
      chatMessages.forEach(m=>{
        const isMine = m.authorId===myDeviceId;
        const row = document.createElement('div');
        row.className = 'chat-row'+(isMine?' mine':'');
        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.textContent = avatarInitial(isMine?myName:m.authorName);
        const bubble = document.createElement('div');
        bubble.className = 'chat-msg';
        const text = document.createElement('div');
        text.className = 'chat-text';
        text.textContent = m.text;
        const meta = document.createElement('div');
        meta.className = 'chat-meta';
        meta.innerHTML = `
          <span class="material-icons-outlined" style="font-size:12px;color:#94a3b8;">schedule</span>
          <span>${formatDateTime(m.ts||Date.now())}</span>
        `;
        bubble.appendChild(text);
        bubble.appendChild(meta);
        if(isMine){
          row.appendChild(bubble);
          row.appendChild(avatar);
        }else{
          row.appendChild(avatar);
          row.appendChild(bubble);
        }
        frag.appendChild(row);
      });
      chatListEl.appendChild(frag);
      scrollChatToBottom();
    }
    function scrollChatToBottom(){
      chatListEl.scrollTop = chatListEl.scrollHeight + 1000;
    }
    async function sendChatMessage(){
      const text = (chatInputEl.value||'').trim();
      if(!text) return;
      chatSendBtn.disabled = true;
      try{
        const now = Date.now();
        const newRef = push(ref(db, CHAT_PATH));
        await set(newRef, {
          text,
          authorId: myDeviceId,
          authorName: myName,
          timestamp: now,
          _serverTs: serverTimestamp()
        });
        chatInputEl.value='';
        setLastReadTs(now);
        setTimeout(scrollChatToBottom, 60);
      }catch(err){
        console.error('Failed to send message', err);
        alert('Failed to send message. Please try again.');
      }finally{
        chatSendBtn.disabled = false;
      }
    }
    function updateChatBadge(){
      const lastRead = getLastReadTs();
      const unread = chatMessages.filter(m=>m.authorId!==myDeviceId && (m.ts||0)>lastRead).length;
      if(unread>0){
        chatBadge.textContent = String(unread);
        chatBadge.style.display = 'inline-block';
      }else{
        chatBadge.style.display = 'none';
      }
    }

    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden){
        if (viewCalculationInterval) { clearInterval(viewCalculationInterval); viewCalculationInterval = null; }
      } else {
        if (!viewCalculationInterval) { viewCalculationInterval = setInterval(updateViewingZones, 4000); }
      }
    });
  </script>
</body>
</html>
