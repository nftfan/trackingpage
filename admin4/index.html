<!DOCTYPE html>
<html>
<head>
  <title>Polygon Saver</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    html, body {
      height:100%; width:100%; margin:0; padding:0; overflow:hidden;
      font-family:'Roboto',Arial,sans-serif; background:#f5f5f7;
    }
    #map {
      position:absolute; top:0; left:0; right:0; bottom:0;
      height:100%; width:100%; background:#e9ecef;
    }

    /* SEARCH BAR (NEW) */
    #search-bar {
      position:fixed;
      top:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:1500;
      display:flex;
      align-items:center;
      gap:8px;
      background:#ffffffee;
      backdrop-filter:blur(3px);
      padding:8px 14px 8px 12px;
      border-radius:14px;
      box-shadow:0 4px 16px -4px rgba(0,0,0,0.25);
      max-width:90vw;
    }
    #search-bar input {
      border:1px solid #ccc;
      outline:none;
      padding:7px 10px 7px 32px;
      border-radius:10px;
      font-size:13px;
      min-width:230px;
      background:#f7f7f9;
      transition:border .18s, background .18s;
    }
    #search-bar input:focus {
      border-color:#4285f4;
      background:#fff;
    }
    #search-bar button {
      background:#1976d2;
      color:#fff;
      border:none;
      padding:8px 14px;
      font-size:12px;
      font-weight:500;
      border-radius:9px;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:4px;
    }
    #search-bar button:disabled {
      opacity:.55; cursor:default;
    }
    #search-bar .material-icons.search-icon {
      position:absolute;
      left:18px;
      font-size:18px;
      pointer-events:none;
      color:#777;
    }
    #search-wrapper {
      position:relative;
      display:flex;
      align-items:center;
    }
    #search-result-badge {
      background:#222;
      color:#fff;
      padding:6px 10px;
      border-radius:9px;
      font-size:11px;
      font-weight:500;
      max-width:220px;
      line-height:1.2;
    }
    #clear-search {
      background:#e0e0e5;
      color:#444;
      border:none;
      width:28px;
      height:28px;
      border-radius:50%;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      font-weight:600;
      line-height:0;
    }
    #clear-search:hover { background:#d5d5da; }

    /* Auto-suggestions list */
    #suggestions {
      position:absolute;
      left:0; top:100%;
      margin-top:4px;
      background:#fff;
      box-shadow:0 6px 18px -4px rgba(0,0,0,0.25);
      border-radius:10px;
      list-style:none;
      padding:6px 0;
      max-height:260px;
      overflow:auto;
      width:100%;
      z-index:1600;
      display:none;
    }
    #suggestions li {
      padding:7px 11px;
      font-size:12.5px;
      cursor:pointer;
      display:flex;
      gap:6px;
      align-items:center;
    }
    #suggestions li:hover {
      background:#f1f4ff;
    }
    #suggestions small {
      opacity:.65;
      font-size:11px;
    }

    .action-bar {
      position:fixed;
      bottom:18px;
      right:10px;
      z-index:1001;
      display:flex;
      flex-direction:column;
      gap:8px;
      background:rgba(255,255,255,0.98);
      border-radius:14px;
      box-shadow:0 2px 12px rgba(0,0,0,0.12);
      padding:10px 8px 10px 8px;
    }
    .action-btn {
      outline:none;
      border:none;
      border-radius:8px;
      background:#fff;
      color:#444;
      font-size:11px;
      padding:6px 10px 6px 8px;
      display:flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
      box-shadow:0 1px 5px rgba(0,0,0,0.08);
      transition:background .18s;
      min-width:0;
      width:100%;
      font-weight:500;
      letter-spacing:0.03em;
    }
    .action-btn:active, .action-btn.selected {
      background:#e3e8fd;
      color:#0060df;
    }
    .action-btn.delete { color:#e53935; }
    .action-btn.copy { color:#43a047; }
    .action-btn.save { color:#007bff; }
    .action-btn.selectall { color:#6c757d; }
    .action-btn.buildings { color:#222; }
    .material-icons {
      font-size:14px;
      margin-right:3px;
      vertical-align:middle;
    }
    .leaflet-popup-content-wrapper { border-radius:8px; font-size:10px; }
    .selected-polygon { stroke:#43a047 !important; stroke-width:5 !important; fill-opacity:0.2 !important; }

    @media (max-width:600px) {
      #search-bar { top:8px; padding:7px 10px; }
      #search-bar input { min-width:150px; font-size:12px; }
      #search-result-badge { display:none; }
      .action-bar {
        right:0; left:0; bottom:0;
        border-radius:11px 11px 0 0;
        flex-direction:row;
        gap:2px;
        justify-content:space-around;
        padding:7px 3px 5px 3px;
      }
      .action-btn {
        font-size:10px;
        min-width:0;
        padding:6px 7px;
        border-radius:7px;
      }
    }

    ::-webkit-scrollbar { width:2px; background:#eee; }
    ::-webkit-scrollbar-thumb { background:#ddd; border-radius:2px; }

    /* PIN popup */
    #pin-popup-bg {
      position:fixed;
      left:0; top:0; right:0; bottom:0;
      background:rgba(0,0,0,0.18);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:3000;
    }
    #pin-popup {
      background:#fff;
      border-radius:10px;
      box-shadow:0 2px 16px rgba(0,0,0,0.19);
      padding:22px 20px 18px 20px;
      min-width:260px;
      max-width:95vw;
      text-align:center;
    }
    #pin-popup input[type="password"] {
      font-size:15px;
      padding:6px 12px;
      margin:8px 0 18px 0;
      border-radius:7px;
      border:1px solid #bbb;
      width:80%;
      text-align:center;
      letter-spacing:0.18em;
    }
    #pin-popup button {
      background:#007bff;
      color:#fff;
      border:none;
      padding:7px 14px;
      border-radius:7px;
      cursor:pointer;
      font-size:13px;
      margin-right:7px;
      font-weight:500;
    }
    #pin-popup button.cancel {
      background:#eee;
      color:#333;
    }
    #pin-popup .err-msg {
      color:#d32f2f;
      font-size:11px;
      margin-bottom:7px;
      display:none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- SEARCH BAR (NEW) -->
  <div id="search-bar">
    <div id="search-wrapper">
      <span class="material-icons search-icon">search</span>
      <input id="search-input" type="text" placeholder="Search Belgian town..." autocomplete="off">
      <ul id="suggestions"></ul>
    </div>
    <button id="search-btn" title="Search">
      <span class="material-icons" style="font-size:16px;">travel_explore</span>Go
    </button>
    <button id="clear-search" title="Clear search" style="display:none;">Ã—</button>
    <div id="search-result-badge" style="display:none;"></div>
  </div>

  <div class="action-bar">
    <button id="save-polygon" class="action-btn save" style="display:none;">
      <span class="material-icons">save</span>Save
    </button>
    <button id="copy-selected" class="action-btn copy" style="display:none;">
      <span class="material-icons">content_copy</span>Copy
    </button>
    <button id="delete-selected" class="action-btn delete" style="display:none;">
      <span class="material-icons">delete</span>Delete
    </button>
    <button id="select-all" class="action-btn selectall" style="display:none;">
      <span class="material-icons">done_all</span>Select All
    </button>
    <button id="view-buildings" class="action-btn buildings" style="display:none;">
      <span class="material-icons">location_city</span>Buildings
    </button>
  </div>

  <!-- PIN popup for delete -->
  <div id="pin-popup-bg">
    <div id="pin-popup">
      <div style="font-size:16px;font-weight:500;margin-bottom:7px;">Enter PIN to Delete</div>
      <input id="pin-input" type="password" maxlength="6" autocomplete="off" placeholder="Enter PIN" />
      <div id="pin-err-msg" class="err-msg">Incorrect PIN!</div>
      <button id="pin-confirm">Confirm</button>
      <button class="cancel" id="pin-cancel">Cancel</button>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>

  <script>
    // ---------------- Firebase Init ----------------
    const firebaseConfig = {
      apiKey: "AIzaSyBHRyOy3hNcWarK8Zk34MWrv_tIYKM7mXM",
      authDomain: "leuvenflyers-23584.firebaseapp.com",
      databaseURL: "https://leuvenflyers-23584-default-rtdb.firebaseio.com",
      projectId: "leuvenflyers-23584",
      storageBucket: "leuvenflyers-23584.firebasestorage.app",
      messagingSenderId: "1077790950414",
      appId: "1:1077790950414:web:036fafe06df86f41ed285f"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ---------------- Map ----------------
    var map = L.map('map', { zoomControl: false }).setView([50.8503, 4.3517], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution:'&copy; OpenStreetMap' }).addTo(map);

    var drawnItems = new L.FeatureGroup().addTo(map);
    var drawControl = new L.Control.Draw({
      draw: { polygon: true, polyline: false, marker: false, circle: false, circlemarker: false, rectangle: false },
      edit: { featureGroup: drawnItems }
    });
    map.addControl(drawControl);

    var lastLayer = null;
    var polygonRefs = {}; // id -> {key, layer, coords}
    var selectedPolygons = new Set();

    // Building layers
    var buildingLayer = L.layerGroup().addTo(map);
    var buildingData = {}; // leaflet_id -> { ids:Set, markers:[] }

    // Search related layers
    var searchBoundaryLayer = L.geoJSON(null, {
      style: { color:'#0052cc', weight:2, fillOpacity:0.05, dashArray:'4 6' }
    }).addTo(map);
    var searchBuildingsLayer = L.layerGroup().addTo(map);

    // ---------------- UI Helpers ----------------
    function showToast(msg, t=2200) {
      let toast = document.createElement('div');
      toast.style.position='fixed';
      toast.style.bottom='28px';
      toast.style.left='50%';
      toast.style.transform='translateX(-50%)';
      toast.style.background="#222";
      toast.style.color="#fff";
      toast.style.fontSize="11px";
      toast.style.borderRadius="7px";
      toast.style.padding="7px 18px";
      toast.style.zIndex="3000";
      toast.style.boxShadow="0 2px 8px rgba(0,0,0,0.12)";
      toast.innerText=msg;
      document.body.appendChild(toast);
      setTimeout(()=>toast.remove(), t);
    }

    function updateActionButtons() {
      const hasPolygons = Object.keys(polygonRefs).length > 0;
      const hasSelection = selectedPolygons.size > 0;

      document.getElementById('copy-selected').style.display = hasSelection ? 'inline-flex' : 'none';
      document.getElementById('delete-selected').style.display = hasSelection ? 'inline-flex' : 'none';
      document.getElementById('select-all').style.display = hasPolygons ? 'inline-flex' : 'none';

      document.getElementById('select-all').innerHTML =
        `<span class="material-icons">done_all</span>` +
        ((selectedPolygons.size === Object.keys(polygonRefs).length && hasPolygons) ? "Unselect" : "Select") + " All";

      const viewBuildingsBtn = document.getElementById('view-buildings');
      if (hasSelection) {
        viewBuildingsBtn.style.display = 'inline-flex';
        const { total } = computeSelectedBuildingStats();
        viewBuildingsBtn.innerHTML =
          `<span class="material-icons">location_city</span>` + (total > 0 ? `Buildings (${total})` : 'Buildings');
      } else {
        viewBuildingsBtn.style.display = 'none';
      }
    }

    // ---------------- Polygon logic ----------------
    map.on('draw:created', function (e) {
      drawnItems.clearLayers();
      lastLayer = e.layer;
      drawnItems.addLayer(lastLayer);
      document.getElementById('save-polygon').style.display = 'inline-flex';
    });

    document.getElementById('save-polygon').onclick = function() {
      if (!lastLayer) return;
      var coords = lastLayer.getLatLngs()[0].map(p => ({lat: p.lat, lng: p.lng}));
      db.ref('polygons').push(coords, function(error) {
        if (!error) {
          showToast('Polygon saved!');
          document.getElementById('save-polygon').style.display = 'none';
          lastLayer = null;
          drawnItems.clearLayers();
          loadPolygons();
        }
      });
    };

    function formatCoordsArray(coordsArray) {
      return '[\n' + coordsArray.map(
        poly => '  [\n' + poly.map(
          pt => `    [${pt[0]}, ${pt[1]}]`
        ).join(',\n') + '\n  ]'
      ).join(',\n') + '\n]';
    }

    function copyToClipboard(str) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(str).then(()=>showToast("Copied!"), ()=>showToast("Failed to copy."));
      } else {
        const ta = document.createElement('textarea');
        ta.value = str; document.body.appendChild(ta); ta.select();
        try { document.execCommand('copy'); showToast("Copied!"); } catch { showToast("Failed to copy."); }
        ta.remove();
      }
    }

    function loadPolygons() {
      drawnItems.clearLayers();
      buildingLayer.clearLayers();
      polygonRefs = {};
      selectedPolygons.clear();
      buildingData = {};

      db.ref('polygons').once('value', function(snapshot) {
        snapshot.forEach(function(child) {
          var raw = child.val();
            var coordsArr = Object.keys(raw)
              .filter(k => !isNaN(Number(k)))
              .sort((a,b)=>Number(a)-Number(b))
              .map(k => [raw[k].lat, raw[k].lng]);
            if (!coordsArr.length) return;

            var polygon = L.polygon(coordsArr, { color:'#d32f2f', weight:2, fillOpacity:0.13 });
            drawnItems.addLayer(polygon);
            polygonRefs[polygon._leaflet_id] = { key: child.key, layer: polygon, coords: coordsArr };

            polygon.on('click', function(ev) {
              togglePolygonSelection(polygon._leaflet_id);
              L.DomEvent.stopPropagation(ev);
            });

            polygon.on('dblclick', function(ev) {
              var coordStr = formatCoordsArray([coordsArr]);
              var popupContent = `<b style="font-size:10px;">Polygon Coords:</b>
                <pre style="max-width:280px;overflow-x:auto;font-size:9px;">${coordStr}</pre>
                <button onclick="window.copyPolygonCoords('${btoa(coordStr)}')" style="font-size:10px;padding:5px 9px;background:#007bff;color:#fff;border:none;border-radius:4px;cursor:pointer;">
                  <span class="material-icons" style="font-size:12px;vertical-align:middle;">content_copy</span>Copy
                </button>
                <br><span style="font-size:9px;color:#999;">Tip: Tap polygon to select for batch.</span>`;
              polygon.bindPopup(popupContent).openPopup();
              L.DomEvent.stopPropagation(ev);
            });
        });
        updateActionButtons();
      });
    }

    function togglePolygonSelection(id) {
      if (!polygonRefs[id]) return;
      if (selectedPolygons.has(id)) {
        selectedPolygons.delete(id);
        polygonRefs[id].layer.setStyle({ color:'#d32f2f', weight:2, fillOpacity:0.13 });
      } else {
        selectedPolygons.add(id);
        polygonRefs[id].layer.setStyle({ color:'#43a047', weight:4, fillOpacity:0.22 });
      }
      updateActionButtons();
      refreshBuildingMarkersVisibility();
    }

    window.copyPolygonCoords = function(encoded) {
      copyToClipboard(atob(encoded));
    };

    // ---------------- Buildings per polygon ----------------
    function polygonToOverpassPoly(coords) {
      let parts = coords.map(c => `${c[0]} ${c[1]}`);
      if (parts[0] !== parts[parts.length - 1]) parts.push(parts[0]);
      return parts.join(' ');
    }

    function buildOverpassQueryForPolygon(coords) {
      const polyStr = polygonToOverpassPoly(coords);
      return `
        [out:json][timeout:40];
        (
          way["building"](poly:"${polyStr}");
          relation["building"](poly:"${polyStr}");
        );
        out center;`;
    }

    async function fetchBuildingsForPolygon(leafletId) {
      if (!polygonRefs[leafletId]) return;
      if (buildingData[leafletId]) return buildingData[leafletId];
      const coords = polygonRefs[leafletId].coords;
      const query = buildOverpassQueryForPolygon(coords);
      const url = "https://overpass-api.de/api/interpreter";
      try {
        const res = await fetch(url, {
          method:'POST',
          body: query,
          headers:{ 'Content-Type':'text/plain' }
        });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const json = await res.json();
        const ids = new Set();
        const markers = [];
        if (json.elements) {
          json.elements.forEach(el => {
            const id = el.type + '/' + el.id;
            if (ids.has(id)) return;
            ids.add(id);
            let lat = el.center ? el.center.lat : (el.lat || (el.bounds && (el.bounds.minlat + el.bounds.maxlat)/2));
            let lon = el.center ? el.center.lon : (el.lon || (el.bounds && (el.bounds.minlon + el.bounds.maxlon)/2));
            if (lat !== undefined && lon !== undefined) {
              const m = L.circleMarker([lat, lon], {
                radius:3, color:'#000', weight:1, fillColor:'#000', fillOpacity:0.9
              }).addTo(buildingLayer);
              markers.push(m);
            }
          });
        }
        buildingData[leafletId] = { ids, markers };
        return buildingData[leafletId];
      } catch (err) {
        console.error('Overpass error:', err);
        showToast('Buildings fetch failed');
        return { ids:new Set(), markers:[] };
      }
    }

    function computeSelectedBuildingStats() {
      const allIds = new Set();
      selectedPolygons.forEach(id => {
        if (buildingData[id]) buildingData[id].ids.forEach(bid => allIds.add(bid));
      });
      return { total: allIds.size };
    }

    function refreshBuildingMarkersVisibility() {
      // Keeping all markers visible for now.
    }

    async function loadBuildingsForSelection() {
      if (selectedPolygons.size === 0) return;
      showToast('Loading buildings...');
      const jobs = [];
      selectedPolygons.forEach(id => { if (!buildingData[id]) jobs.push(fetchBuildingsForPolygon(id)); });
      await Promise.all(jobs);
      const { total } = computeSelectedBuildingStats();
      showToast('Buildings loaded: ' + total);
      updateActionButtons();
    }

    document.getElementById('view-buildings').onclick = () => loadBuildingsForSelection();

    // ---------------- PIN Delete ----------------
    const pinPopupBg = document.getElementById('pin-popup-bg');
    const pinInput = document.getElementById('pin-input');
    const pinConfirm = document.getElementById('pin-confirm');
    const pinCancel = document.getElementById('pin-cancel');
    const pinErrMsg = document.getElementById('pin-err-msg');
    let deleteQueue = [];

    function openPinPopup(queue) {
      deleteQueue = queue;
      pinInput.value = '';
      pinErrMsg.style.display = 'none';
      pinPopupBg.style.display = 'flex';
      pinInput.focus();
    }
    function closePinPopup() {
      pinPopupBg.style.display = 'none';
      deleteQueue = [];
    }
    pinCancel.onclick = closePinPopup;
    pinPopupBg.onclick = e => { if (e.target === pinPopupBg) closePinPopup(); };

    pinConfirm.onclick = function() {
      const PIN = "000888";
      if (pinInput.value === PIN) {
        let promises = [];
        deleteQueue.forEach(id => {
          let ref = polygonRefs[id];
          if (ref) {
            promises.push(db.ref('polygons/' + ref.key).remove());
            drawnItems.removeLayer(ref.layer);
            if (buildingData[id]) {
              buildingData[id].markers.forEach(m => buildingLayer.removeLayer(m));
              delete buildingData[id];
            }
          }
        });
        Promise.all(promises).then(() => {
          selectedPolygons.clear();
          updateActionButtons();
          loadPolygons();
          showToast('Deleted polygons!');
        });
        closePinPopup();
      } else {
        pinErrMsg.style.display = 'block';
        pinInput.value = '';
        pinInput.focus();
      }
    };

    document.getElementById('delete-selected').onclick = function() {
      if (selectedPolygons.size === 0) return;
      openPinPopup(Array.from(selectedPolygons));
    };

    document.getElementById('copy-selected').onclick = function() {
      if (!selectedPolygons.size) return;
      var coordsArray = [];
      selectedPolygons.forEach(id => {
        let ref = polygonRefs[id];
        if (ref) coordsArray.push(ref.coords);
      });
      copyToClipboard(formatCoordsArray(coordsArray));
    };

    document.getElementById('select-all').onclick = function() {
      const allIds = Object.keys(polygonRefs);
      if (selectedPolygons.size === allIds.length) {
        selectedPolygons.forEach(id => {
          const ref = polygonRefs[id];
          if (ref) ref.layer.setStyle({ color:'#d32f2f', weight:2, fillOpacity:0.13 });
        });
        selectedPolygons.clear();
      } else {
        allIds.forEach(id => {
          if (!selectedPolygons.has(id)) {
            selectedPolygons.add(id);
            polygonRefs[id].layer.setStyle({ color:'#43a047', weight:4, fillOpacity:0.22 });
          }
        });
      }
      updateActionButtons();
      refreshBuildingMarkersVisibility();
    };

    // ---------------- Town Search & Building Count (NEW) ----------------
    const searchInput = document.getElementById('search-input');
    const searchBtn = document.getElementById('search-btn');
    const clearBtn = document.getElementById('clear-search');
    const resultBadge = document.getElementById('search-result-badge');
    const suggestionsEl = document.getElementById('suggestions');

    let lastSearchAbort = null;
    let suggestionAbort = null;
    let lastSearchedTown = null;

    function setSearchStatus(text, type='info') {
      if (!text) {
        resultBadge.style.display='none';
        return;
      }
      resultBadge.style.display='inline-block';
      resultBadge.style.background = (type==='error') ? '#c62828' : (type==='success' ? '#2e7d32' : '#222');
      resultBadge.textContent = text;
    }

    function clearSearchResult() {
      searchBuildingsLayer.clearLayers();
      searchBoundaryLayer.clearLayers();
      setSearchStatus('');
      lastSearchedTown = null;
      clearBtn.style.display='none';
    }

    clearBtn.onclick = function() {
      searchInput.value = '';
      clearSearchResult();
      suggestionsEl.style.display='none';
    };

    function debounce(fn, ms) {
      let t; return function(...args) {
        clearTimeout(t);
        t = setTimeout(()=>fn.apply(this,args), ms);
      };
    }

    // Fetch suggestions (limit 5)
    async function fetchSuggestions(q) {
      if (suggestionAbort) suggestionAbort.abort();
      suggestionAbort = new AbortController();
      if (!q || q.length < 2) {
        suggestionsEl.style.display='none';
        suggestionsEl.innerHTML='';
        return;
      }
      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&countrycodes=be&limit=5&q=${encodeURIComponent(q)}`;
        const res = await fetch(url, {
          headers:{ 'Accept':'application/json', 'User-Agent':'polygon-saver/1.0' },
          signal: suggestionAbort.signal
        });
        if (!res.ok) return;
        const data = await res.json();
        if (!data.length) {
          suggestionsEl.style.display='none';
          suggestionsEl.innerHTML='';
          return;
        }
        suggestionsEl.innerHTML = data.map(item => {
          const disp = item.display_name;
          const town = (item.address && (item.address.town || item.address.city || item.address.village || item.address.municipality)) || item.display_name.split(',')[0];
          return `<li data-osm-type="${item.osm_type}" data-osm-id="${item.osm_id}" data-json='${encodeURIComponent(JSON.stringify(item))}'>
            <span class="material-icons" style="font-size:16px;color:#666;">location_on</span>
            <div style="flex:1;">
              <div style="font-size:12.5px;font-weight:500;">${town}</div>
              <small>${disp}</small>
            </div>
          </li>`;
        }).join('');
        suggestionsEl.style.display='block';
        Array.from(suggestionsEl.querySelectorAll('li')).forEach(li => {
          li.onclick = () => {
            const item = JSON.parse(decodeURIComponent(li.dataset.json));
            searchInput.value = (item.address && (item.address.town || item.address.city || item.address.village || item.address.municipality)) || item.display_name.split(',')[0];
            suggestionsEl.style.display='none';
            performSearch(item); // using selected item
          };
        });
      } catch(e) {
        // swallow
      }
    }

    const debouncedSuggest = debounce(() => fetchSuggestions(searchInput.value.trim()), 300);
    searchInput.addEventListener('input', debouncedSuggest);

    searchInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        suggestionsEl.style.display='none';
        performSearch(); // raw query
      } else if (e.key === 'Escape') {
        suggestionsEl.style.display='none';
      }
    });

    searchBtn.onclick = () => performSearch();

    async function performSearch(preSelectedItem=null) {
      const q = preSelectedItem
        ? ((preSelectedItem.address && (preSelectedItem.address.town || preSelectedItem.address.city || preSelectedItem.address.village || preSelectedItem.address.municipality)) || preSelectedItem.display_name.split(',')[0])
        : searchInput.value.trim();

      if (!q) {
        showToast('Enter a town name');
        return;
      }
      if (lastSearchAbort) lastSearchAbort.abort();
      lastSearchAbort = new AbortController();

      setSearchStatus('Searching...');
      searchBtn.disabled = true;

      try {
        let item = preSelectedItem;
        if (!item) {
          // Main geocoding request
            const url = `https://nominatim.openstreetmap.org/search?format=json&polygon_geojson=1&addressdetails=1&countrycodes=be&limit=1&q=${encodeURIComponent(q)}`;
            const res = await fetch(url, {
              headers:{ 'Accept':'application/json', 'User-Agent':'polygon-saver/1.0' },
              signal: lastSearchAbort.signal
            });
            if (!res.ok) throw new Error('Search failed');
            const data = await res.json();
            if (!data.length) {
              setSearchStatus('Not found', 'error');
              searchBtn.disabled = false;
              return;
            }
            item = data[0];
        }

        lastSearchedTown = q;
        clearBtn.style.display='inline-flex';

        // Fit map to bounding box
        if (item.boundingbox) {
          const bb = item.boundingbox.map(Number);
          const south = bb[0], north = bb[1], west = bb[2], east = bb[3];
          map.fitBounds([[south, west],[north, east]]);
        } else if (item.lat && item.lon) {
          map.setView([item.lat, item.lon], 14);
        }

        // Draw boundary if polygon available
        searchBoundaryLayer.clearLayers();
        if (item.geojson && (item.geojson.type === 'Polygon' || item.geojson.type === 'MultiPolygon')) {
          searchBoundaryLayer.addData(item.geojson);
        }

        setSearchStatus('Counting buildings...');
        // Compute area id from osm_type/id
        const osmType = item.osm_type; // "relation" | "way" | "node"
        const osmId = Number(item.osm_id);
        let areaId;
        if (osmType === 'relation') areaId = 3600000000 + osmId;
        else if (osmType === 'way') areaId = 2400000000 + osmId;
        else if (osmType === 'node') areaId = 3600000000 + osmId; // fallback; may not always have boundary area
        // Overpass query
        const overpass = `
[out:json][timeout:70];
area(${areaId})->.a;
(
  way["building"](area.a);
  relation["building"](area.a);
);
out center;`;

        const overRes = await fetch('https://overpass-api.de/api/interpreter', {
          method:'POST',
          body: overpass,
          headers:{ 'Content-Type':'text/plain' }
        });
        if (!overRes.ok) throw new Error('Overpass busy');

        const overJson = await overRes.json();
        const seen = new Set();
        const markers = [];
        if (overJson.elements) {
          overJson.elements.forEach(el => {
            const id = el.type + '/' + el.id;
            if (seen.has(id)) return;
            seen.add(id);
            if (seen.size <= 3000) { // cap markers for performance
              let lat = el.center ? el.center.lat : el.lat;
              let lon = el.center ? el.center.lon : el.lon;
              if (lat !== undefined && lon !== undefined) {
                markers.push([lat, lon]);
              }
            }
          });
        }

        // Show small sampling of markers (optional)
        searchBuildingsLayer.clearLayers();
        markers.forEach(pt => {
          L.circleMarker(pt, {
            radius:2,
            color:'#ff9800',
            weight:1,
            fillColor:'#ff9800',
            fillOpacity:0.85
          }).addTo(searchBuildingsLayer);
        });

        const total = seen.size;
        setSearchStatus(`${q}: ${total.toLocaleString()} building${total===1?'':'s'}`, total ? 'success' : 'info');
        showToast(`Found ${total.toLocaleString()} buildings in ${q}`);
      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        setSearchStatus('Error', 'error');
        showToast('Search error');
      } finally {
        searchBtn.disabled = false;
      }
    }

    // ---------------- Init ----------------
    window.onload = loadPolygons;
  </script>
</body>
</html>
